---
title: Monitoring Redis for PCF
owner: London Services
---

<strong><%= modified_date %></strong>

The Loggregator Firehose exposes Redis metrics. You can use third-party monitoring tools to consume Redis metrics to monitor Redis performance and health. For an example Datadog configuration that displays some of the significant metrics outlined below, see the [CF Redis example dashboard](https://github.com/pivotal-cf/metrics-datadog-dashboard). Pivotal does not endorse or provide support for any third party solution.


## <a id="polling"></a> Metrics Polling Interval
The metrics polling interval defaults to 30 seconds. This can be changed by navigating to the Metrics configuration page and entering a new value in **Metrics polling interval (min: 10)**.

![Metrics Polling Interval](metrics_polling.png)

Metrics are emitted in the following format:

<pre class=terminal>
origin:"p-redis" eventType:ValueMetric timestamp:1480084323333475533 deployment:"cf-redis" job:"cf-redis-broker" index:"{redacted}" ip:"10.0.1.49" valueMetric:&#60;name:"/p-redis/service-broker/dedicated_vm_plan/available_instances" value:4 unit:"" >
</pre>

## <a id="kpi"></a>Key Performance Indicators

Key Performance Indicators (KPIs) for Redis for PCF are metrics that operators find most useful for monitoring their Redis service to ensure smooth operation. KPIs are high-signal-value metrics that can indicate emerging issues. KPIs can be raw component metrics or _derived_ metrics generated by applying formulas to raw metrics.

Pivotal provides the following KPIs as general alerting and response guidance for typical Redis for PCF installations.
Pivotal recommends that operators continue to fine-tune the alert measures to their installation by observing historical trends.
Pivotal also recommends that operators expand beyond this guidance and create new, installation-specific monitoring
metrics, thresholds, and alerts based on learning from their own installations.

For a list of all Redis metrics, see [Redis Metrics](#redis-metrics).

### <a id="Redis-KPIs"></a> Redis for PCF Service KPIs

#### <a id="total-od-instances"</a> Total Instances For On-Demand Service

<table>
   <tr><th colspan="2" style="text-align: center;"><br> total_instances <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      Total instances provisioned by application developers across all On-Demand Services and for a specific On-Demand plan
      <strong>Use</strong>: Track instance use by app developers.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: count<br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Daily</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: N/A  <br>
      <strong>Red critical</strong>: N/A </td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      N/A
      </td>
   </tr>
</table>

#### <a id="quota-remaining-od-instances"</a> Quota Remaining For On-Demand Service

<table>
   <tr><th colspan="2" style="text-align: center;"><br> total_instances <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
       Number of available instances across all On-Demand Services and for a specific On-Demand plan.
      <strong>Use</strong>: Track remaining resources available for app developers.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: count<br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Daily</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: 3  <br>
      <strong>Red critical</strong>: 0 </td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      Increase quota allowed for the specific plan or across all on-demand services.
      </td>
   </tr>
</table>

#### <a id="quota-remaining-dedicated-instances"</a> Quota Remaining For Shared-VM and Dedicated-VM Service

<table>
   <tr><th colspan="2" style="text-align: center;"><br> /p-redis/service-broker/dedicated_vm_plan/available_instances /p-redis/service-broker/shared_vm_plan/available_instances <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
       Number of available instances for the Dedicated-VM serving.
      <strong>Use</strong>: Track remaining resources available for app developers.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: count<br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Daily</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: 2  <br>
      <strong>Red critical</strong>: 0 </td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      Increase VMs available for the Dedicated-VM service.
      </td>
   </tr>
</table>

### <a id="Redis-KPIs"></a> Redis KPIs

#### <a id="persistent-disk-percent"></a> Percent of Persistent Disk Used

<table>
   <tr><th colspan="2" style="text-align: center;"><br> persistent.disk.percent <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      `persistent.disk.percent` is the percentage of persistent disk being used on a VM. The persistent disk is specified as an IaaS specific disk type with a size. For example, `pd-standard` on GCP, or `st1` on AWS, with disk size 5GB. It is a metric relevant to the health of the vm; a percentage of disk usage approaching 100 will cause the vm disk to become unusable as no more files will be allowed to be written.
      <strong>Use</strong>: Redis is an in-memory data store that uses a persistent disk to backup and restore the dataset in case of upgrades and VM restarts.
      <br><br>
      <strong>Origin</strong>: JMX Bridge or BOSH HM<br>
      <strong>Type</strong>: percent<br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Average over last 10 minutes</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: >75 <br>
      <strong>Red critical</strong>: >90 </td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      Operator should ensure that the disk is at least 3.5x VM memory. If it is, then Operator should contact GSS. If it is not, then the Operator should increase disk space.
      </td>
   </tr>
</table>

#### <a id="used-memory-max-memory"></a> Used Memory Percent

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.memory.used_memory / info.memory.maxmemory  <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      info.memory.used_memory is a metric of the total number of bytes allocated by Redis using its allocator (either standard libc, jemalloc, or an alternative allocator such as tcmalloc). maxmemory is a configuration option for the total memory made available to the Redis instance. The ratio returns the percentage of used memory out of available memory.
      <strong>Use</strong>: This is a performance metric that is most critical for Redis instances with a `maxmemory-policy` of `allkeys-lru`
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: percentage <br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Application-specific based on velocity of data flow.
          Some options are:
          1. individual data points
          2. average over last 10 minutes
          3. maximum of last 10 minutes

          Factors to consider:
          1. Usage: if key eviction is in place (e.g. cache use case), (2) gives enough detail. If key eviction is not in place, (1) or (3) give more useful information to ensure that high usage triggers an alert.</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: 80%
Not applicable for cache usage. When used as a cache, Redis will typically use up to maxmemory and then evict keys to make space for new entries.

A different threshold might be appropriate for specific use cases of no key eviction, to allow for reaction time. Factors to consider:
1. Traffic load on application. Higher traffic means that Redis memory will fill up faster.
2. Average size of data added/ transaction. The more data added to Redis on a single transaction, the faster Redis will fill up its memory.<br>
      <strong>Red critical</strong>: 90%. See warning specific threshold information.
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      No action assuming the maxmemory policy set meets your applications needs. If the maxmemory policy does not persist data as you wish, either coordinate a backup cadence or update your maxmemory policy if using the on-demand Redis service.
      </td>
   </tr>
</table>

#### <a id="connected-clients"></a> Connected Clients

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.clients.connected_clients <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      Number of clients currently connected to the Redis instance.
      <strong>Use</strong>: Redis does not close client connections. They remain open until closed explicitly by the client or another script. Once the connected_clients reaches maxclients, Redis will stop accepting new connections and begin producing errors `ERR max number of clients reached`.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: number <br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Average over last 10 minutes</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: Application Specific. When connected clients reaches max clients, no more clients can connect. This alert should be at the level where it can tell you that your application has scaled to a certain level and may require action.<br>
      <strong>Red critical</strong>: Application Specific. When connected clients reaches max clients, no more clients can connect. This alert should be at the level where it can tell you that your application has scaled to a certain level and may require action.</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
      Increase max clients for your instance (if using the on-demand service) or reduce the number of connected cleints.
      </td>
   </tr>
</table>

#### <a id="blocked-clients"></a> Blocked Clients

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.clients.blocked_clients <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      The number of clients waiting on a blocking call. Redis provides two types of primitive commands to retrieve items from lists: standard and blocking.
      The standard commands (LPOP, RPOP, RPOPLPUSH) immediately return an item from a list. If there are no items available the standard pop comands return nil.
      The blocking commands (BLPOP, BRPOP, BRPOPLPUSH) will wait for an empty list to become non-empty.
      The client connection will be blocked until an item is added to the lists it is watching. Only the client which made the blocking request is blocked, the Redis server continues to serve other clients. The blocking commands each take an additional `timeout` argument that is the time in seconds the server will wait on a list before returning nil. A blocking command with timeout `0` will wait forever. Multiple clients may be blocked waiting for the same list. Details of the blocking commands can be found at: https://redis.io/commands/blpop
      <strong>Use</strong>: Blocking commands can be useful to avoid clients regularily polling the server for new data. The blocked_clients metric is the number of clients currently blocked waiting on a blocking request they have made to the Redis server.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: number <br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Application-specific. Change from baseline may be more significant than actual value.</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: The expected range of the blocked_clients metric depends on what Redis is being used for:

- Many uses will have no need for blocking commands and should expect blocked_clients to always be zero.
- If blocking commands are being used to force a recipient client to wait for a required input, a raised blocked_clients might suggest a problem with the source clients.
- blocked_clients might be expected to be high in situations where Redis is being used for infrequent messaging.

If blocked_clients is expected to be non-zero, warnings could be based on change from baseline. A sudden rise in blocked_clients could be caused by source clients failing to provide data required by blocked clients. </td>
      <strong>Red critical</strong>: There is no blocked_clients threshold critical to the function of Redis.

However a problem that is causeing blocked_clients to rise might often cause a rise in connected_clients.
Connected_clients does have a hard upper limit and should be used to trigger alerts.</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
        Analysis could include:
- checking the connected_clients metric. blocked_clients would often rise in concert with connected_clients.
- establishing whether the rise in blocked_clients is accompanied by an overall increase in applications connecting to Redis, or by an asymmetry in clients providing and recieving data with blocking commands
- considering whether a change in blocked_clients is most likely caused by oversupply of blocking requests or undersupply of data
- considering whether a change in network latency is delaying the data from source clients

In general a rise or change in blocked_clients is more likely to suggest a problem in the network or infrastructure, or in the function of client applications, rather than a problem with the Redis service.
      </td>
   </tr>
</table>

#### <a id="memory-fragmentation-ratio"></a> Memory Fragmentation Ratio

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.memory.mem_fragmentation_ratio <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      Ratio of the amount of memory allocated to Redis by the OS to the amount of memory that Redis is using
      <strong>Use</strong>: A memory fragmentation less than one shows that the memory used by Redis is higher than the OS available memory. In other packagings of redis, large values reflect memory fragmentation. For Redis for PCF, the instances only run Redis meaning that no other processes will be affected by a high fragmentation ratio (e.g., 10 or 11).
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: ratio <br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Average over last 10 minutes</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: < 1. Less than 1 indicates that the memory used by Redis is higher than the OS available memory which can lead to performance degradations. <br>
      <strong>Red critical</strong>: Same as warning threshold.</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
        Restart the Redis server to normalise fragmentation ratio.
      </td>
   </tr>
</table>

#### <a id="instantaneous-ops-per-sec"></a> Instantaneous Operations Per Second

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.stats.instantaneous_ops_per_sec <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      The number of commands processed per second by the redis server. Note the instantaneous_ops_per_sec is calculated as the mean of the recent samples taken by the server. The number of recent samples is hardcoded as 16 in the implementation of Redis.
      <strong>Use</strong>: The higher the commands processed per second, the better the performance of Redis. This is because Redis is single threaded and the commands are processed in sequence. A higher throughput would thus mean faster response per request which is a direct indicator of higher performance. A drop in the number of commands processed per second as compared to historical norms could be a sign of either low command volume or slow commands blocking the system. Low command volume could be normal, or it could be indicative of problems upstream.
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: count <br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Every 30 seconds</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: A drop in the count compared to historical norms could be a sign of either low command volume or slow commands blocking the system. Low command volume could be normal, or it could be indicative of problems upstream. Slow commands could be due to latency issue, a large number of clients being connected to the same instance, memory being swapped out, etc. Thus, the count is possibly a symptom of compromised Redis performace. (Although expected low command volume is a valid case where it is not.)<br>
      <strong>Red critical</strong>: A very low count or a large drop from previous counts may indicate a downturn in performance that should ensue an investigation. This is unless the low traffic is expected behaviour.</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
        Drop in the count may be a symptom of compromised Redis performace. The following are possible steps that can be taken in response to this:

1. Identify slow commands using the slowlog:

Redis logs all the commands that take more than a specified amount of time in slowlog. By default, this time is set to 20ms and the slowlog is allowed a maximum of 120 commands. For the purposes of slowlog, execution time is the time taken by Redis alone and does not account for time spent in I/O. So it would not log slow commands solely due to network latency.

Given that typical commands, including network latency, take about 200microseconds, a 20ms Redis execution time is 100 times slower. This could be indicative of memory management issues wherein Redis pages have been swapped to disk.

To see all the commands with slow Redis execution times, type slowlog get in the redis-cli.

2. Monitor client connections:

Because Redis is single threaded, one process services requests from all clients. As the number of clients grows, the percentage of resource time given to each client decreases and each client spends an increasing time waiting for their share of Redis server time.

Monitoring the number of clients may be important because there may be applications creating connections that you did not expect or your application may not be efficiently closing unused connections.

The connected clients metrics can be used to monitor this. This can also be viewed from the redis-cli using the command "info clients".

3. Limit client connections:

This currently defaults to 1000 but depending on the application, you may wish to limit this even further. This can be done be running the command "config set maxclients <value>" in the redis-cli. Connections that exceed the limit will be rejected and closed immediately.

Setting maxclients is important to limit the number of unintended client connections and should be set to around 110% to 150% of your expected peak number of connections. In addition, because an error message is returned for failed connection attempts, the maxclient limit warns you that a significant number of unexpected connections are occurring. This will ultimately help maintaining optimal Redis performance.

4. Improve memory management:

Poor memory can cause increased latency in Redis. If your Redis instance is using more memory than is available, the operating system will swap parts of the redis process from out of phyical memory and onto disk. Swapping will significantly reduce Redis performance since reads from disk are about 5 orders or magnitude slower than reads from physical memory.


      </td>
   </tr>
</table>

#### <a id="keyspace-hits-keyspace-misses"></a> Keyspace Hits / Keyspace Misses

<table>
   <tr><th colspan="2" style="text-align: center;"><br> info.stats.keyspace_hits / info.stats.keyspace_misses <br><br></th></tr>
   <tr>
      <th width="25%">Description</th>
      Hit ratio to determine share of keyspace hits that are successful
      <strong>Use</strong>: A memory fragmentation less than one shows that the memory used by Redis is higher than the OS available memory. In other packagings of redis, large values reflect memory fragmentation. For Redis for PCF, the instances only run Redis meaning that no other processes will be affected by a high fragmentation ratio (e.g., 10 or 11).
      <br><br>
      <strong>Origin</strong>: Doppler/Firehose<br>
      <strong>Type</strong>: ratio <br>
      <strong>Frequency</strong>: 30 s (default), 10 s (configurable minimum)<br>
   </tr>
   <tr>
      <th>Recommended measurement</th>
      <td>Application specific</td>
   </tr>
   <tr>
      <th>Recommended alert thresholds</th>
      <td><strong>Yellow warning</strong>: Application specific. In general depending how an application is using the cache, an expected hit ratio value can vary between 60% to 99% . Also same hit ratio values can mean different things for different applications. Everytime an application gets a cache miss it means it will probably go to and fetch the data from a more slow resource. This cache miss cost can be different per application. The application developers might be able to provide a threshold which meaning for the app and its performance<br>
      <strong>Red critical</strong>: Application specific (see warning threshold)</td>
   </tr>
   <tr>
      <th>Recommended response</th>
      <td>
        Application specific (see warning threshold section). Work with application developers to understand the performance and cache configuration required for their applications.
      </td>
   </tr>
</table>


## <a id="bosh-health"></a> BOSH Health Monitor Metrics

<%= partial '../../redis/odb/bosh_health_metrics' %>

## <a id="other-metrics"></a>Other Redis Metrics
Redis also exposes the following metrics. for more information, see the [Redis documentation](http://redis.io/commands/INFO).

* <code>arch\_bits</code>
* <code>uptime\_in\_seconds</code>
* <code>uptime\_in\_days</code>
* <code>hz</code>
* <code>lru\_clock</code>
* <code>client\_longest\_output\_list</code>
* <code>client\_biggest\_input\_buf</code>
* <code>used\_memory\_rss</code>
* <code>used\_memory\_peak</code>
* <code>used\_memory\_lua</code>
* <code>loading</code>
* <code>rdb\_bgsave\_in\_progress</code>
* <code>rdb\_last\_save\_time</code>
* <code>rdb\_last\_bgsave\_time\_sec</code>
* <code>rdb\_current\_bgsave\_time\_sec</code>
* <code>aof\_rewrite\_in\_progress</code>
* <code>aof\_rewrite\_scheduled</code>
* <code>aof\_last\_rewrite\_time\_sec</code>
* <code>aof\_current\_rewrite\_time\_sec</code>
* <code>total\_connections\_received</code>
* <code>total\_commands\_processed</code>
* <code>instantaneous\_ops\_per\_sec</code>
* <code>total\_net\_input\_bytes</code>
* <code>total\_net\_output\_bytes</code>
* <code>instantaneous\_input\_kbps</code>
* <code>instantaneous\_output\_kbps</code>
* <code>rejected\_connections</code>
* <code>sync\_full</code>
* <code>sync\_partial\_ok</code>
* <code>sync\_partial\_err</code>
* <code>expired\_keys</code>
* <code>evicted\_keys</code>
* <code>keyspace\_hits</code>
* <code>keyspace\_misses</code>
* <code>pubsub\_channels</code>
* <code>pubsub\_patterns</code>
* <code>latest\_fork\_usec</code>
* <code>migrate\_cached\_sockets</code>
* <code>repl\_backlog\_active</code>
* <code>repl\_backlog\_size</code>
* <code>repl\_backlog\_first\_byte\_offset</code>
* <code>repl\_backlog\_histlen</code>
* <code>used\_cpu\_sys</code>
* <code>used\_cpu\_user</code>
* <code>used\_cpu\_sys\_children</code>
* <code>used\_cpu\_user\_children</code>
* <code>rdb\_last\_bgsave\_status</code>
* <code>aof\_last\_bgrewrite\_status</code>
* <code>aof\_last\_write\_status</code>
